package DamageDetection

import OnUnitEnterLeave
import LinkedList
import HashMap

/**
 *
 */
constant int BUCKET_SIZE = 1

/**
 *
 */
constant real CLEAR_TIMEOUT = 2

/**
 *
 */
bool IS_ENABLED = true

/**
 * 
 */
boolexpr functions = null

/**
 *
 */
public function canDetectDamage(unit whichUnit) returns bool
	return true

class OnDamageTrigger
	/**
	 *
	 */
	private static HashMap<unit, int> hashMap = new HashMap<unit, int>()
	
	/**
	 *
	 */
	private trigger _trigger
	
	/**
	 *
	 */
	private LinkedList<unit> units
	
	/**
	 *
	 */
	private int leaks
	
	/**
	 *
	 */
	static function getOnDamageTriggerFromUnit(unit whichUnit) returns OnDamageTrigger
		return hashMap.get(whichUnit) castTo OnDamageTrigger
	
	/**
	 *
	 */
	private static function setDamageTriggerToUnit(unit whichUnit, OnDamageTrigger _trigger)
		if (_trigger != null)
			hashMap.put(whichUnit, _trigger castTo int)
		else
			hashMap.remove(whichUnit)
	
	/**
	 *
	 */	
	function hasLeaks() returns bool
		return this.leaks > 0
	
	/**
	 *
	 */
	function notifyEnabledDisabledTrigger()
		if (IS_ENABLED)
			this._trigger.enable()
		else
			this._trigger.disable()
	
	/**
	 *
	 */
	function notifyAddedFunction()
		this._trigger.clearConditions()
		this._trigger.addCondition(functions)
	
	/**
	 *
	 */
	private function reRegisterAllUnits()
		LLIterator<unit> allUnits = this.units.iterator()
		
		while (allUnits.hasNext())
			this._trigger.registerUnitEvent(allUnits.next(), EVENT_UNIT_DAMAGED)
			
		allUnits.close()
	
	/**
	 *
	 */
	function rebuild()		
		this._trigger.destr()
		this._trigger = CreateTrigger()
		
		this.leaks = 0
		
		this.reRegisterAllUnits()
		this.notifyEnabledDisabledTrigger()
		this.notifyAddedFunction()
	
	/**
	 *
	 */
	function canRegisterUnits() returns bool
		return this.units.getSize() < BUCKET_SIZE
	
	/**
	 *
	 */
	function addUnit(unit whichUnit) returns bool		
		if (whichUnit == null)
			return false
		
		if (this.canRegisterUnits() == false)
			return false
		
		if (canDetectDamage(whichUnit) == false)
			return false
		
		// Check if already registered
		if (OnDamageTrigger.getOnDamageTriggerFromUnit(whichUnit) != null)
			return false
		
		this._trigger.registerUnitEvent(whichUnit, EVENT_UNIT_DAMAGED)
		this.units.add(whichUnit)
		
		OnDamageTrigger.setDamageTriggerToUnit(whichUnit, this)
		
		return true
	
	/**
	 *
	 */
	function removeUnit(unit whichUnit)
		// Avoid units who are not registered in this instance
		if (OnDamageTrigger.getOnDamageTriggerFromUnit(whichUnit) == this)
			BJDebugMsg("leaking")
			this.leaks++
			this.units.remove(whichUnit)
			
			OnDamageTrigger.setDamageTriggerToUnit(whichUnit, null)
	
	/**
	 *
	 */	
	construct()
		this.units = new LinkedList<unit>()
		this.rebuild()

class OnDamageTriggerPool
	/**
	 *
	 */
	private static LinkedList<OnDamageTrigger> triggers = new LinkedList<OnDamageTrigger>()
	
	/**
	 *
	 */
	private construct()
	
	/**
	 *
	 */
	static function notifyAddedFunction()
		LLIterator<OnDamageTrigger> allTriggers = triggers.iterator()
		
		while (allTriggers.hasNext())
			allTriggers.next().notifyAddedFunction()
			
		allTriggers.close()
	
	/**
	 *
	 */
	static function notifyEnabledDisabledTrigger()
		LLIterator<OnDamageTrigger> allTriggers = triggers.iterator()
		
		while (allTriggers.hasNext())
			allTriggers.next().notifyEnabledDisabledTrigger()
			
		allTriggers.close()
	
	/**
	 *
	 */
	static function clearLeaks()
		LLIterator<OnDamageTrigger> allTriggers = triggers.iterator()
		OnDamageTrigger _trigger = null
		
		while (allTriggers.hasNext())
			_trigger = allTriggers.next()
			
			if (_trigger.hasLeaks())
				_trigger.rebuild()
			
		allTriggers.close()
	
	/**
	 *
	 */
	static function getOnDamageTrigger() returns OnDamageTrigger
		LLIterator<OnDamageTrigger> allTriggers = triggers.iterator()
		OnDamageTrigger _trigger = null
	
		while (allTriggers.hasNext())
			_trigger = allTriggers.next()
			
			if (_trigger.canRegisterUnits())
				break
			else
				_trigger = null

		if (_trigger == null)
			_trigger = new OnDamageTrigger()
			triggers.addtoStart(_trigger)
		
		allTriggers.close()

		return _trigger

/**
 *
 */
public function addOnDamageFunc(boolexpr func)
	functions = Or(functions, func)
	OnDamageTriggerPool.notifyAddedFunction()

/**
 *
 */
public function addOnDamageFunc(code func)
	boolexpr b = Condition(func)
	addOnDamageFunc(b)

/**
 *
 */
public function enableDamageDetection()
	IS_ENABLED = true
	OnDamageTriggerPool.notifyEnabledDisabledTrigger()

/**
 *
 */	
public function disableDamageDetection()
	IS_ENABLED = false
	OnDamageTriggerPool.notifyEnabledDisabledTrigger()
			
init
	// Auto clear all leaks
	CreateTimer().startPeriodic(CLEAR_TIMEOUT, () -> OnDamageTriggerPool.clearLeaks())
	
	// Auto register entering units
	onEnter(() -> OnDamageTriggerPool.getOnDamageTrigger().addUnit(getEnterLeaveUnit()))
	
	// Auto unregister leaver units
	onLeave(() -> begin
		unit leaver = getEnterLeaveUnit()
		OnDamageTrigger.getOnDamageTriggerFromUnit(leaver).removeUnit(leaver)
		leaver = null
	end)